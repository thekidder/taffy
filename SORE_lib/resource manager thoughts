the construction of the resource manager is slightly complex, but after initialization is very easy to use.

after initialization:
ResourceManager* rm = ResourceManager::GetManager();
res_handle some_tex = rm->Register("data/Textures/some_texture.tga");

...

Texture some_texture = rm->GetPtr(some_tex); or
Texture some_texture = rm->GetPtr("data/Textures/some_texture.tga");

Each type of resource is a class derived from class Resource. It must have Load( char* filename), Load(char* bytes, int len), and Unload() functions defined. Its internal data representation is simply a pointer to some bytes.
		
For ResourceManager to know how to instantiate different types of resources, this method is used:
ResourceManager keeps two structures mapping file extensions to function pointers. Thus, when a new resource type is needed, a class is derived from Resource, and RES_LOAD and RES_LOAD_DATA functions are defined then registered in ResourceManager.



-----------------
new details:
-Again, all resource types are derived from class Resource
-ResourceManager is not a singleton, instead it is either passed to each class or a member of GameKernel
-ResourceManager has no function besides making sure no file is loaded twice
-a class will query ResourceManager with a filename. If the filename is not in the ResourceManager's cache, it will load it and return a boost::shared_ptr<Resource*> to the resource.


Templated ResourceManager? Automagically dynamic_casts the Resource* to requested type
usage:
boost::shared_ptr<Texture*> = rm->GetFile<Texture*>("file.tga");